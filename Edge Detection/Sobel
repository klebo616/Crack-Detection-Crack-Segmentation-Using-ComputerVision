import cv2
import numpy as np
import os
from shutil import move

# ----------------------------- Config -----------------------------
INPUT_DIR             = r"C:\Users\bob1k\Desktop\MASTER\Thesis\CNN\.venv\contrast_stretched"
GEN_MASKS_DIR         = r"C:\Users\bob1k\Desktop\MASTER\Thesis\CNN\.venv\generated_masks"   # new masks written here
OLD_MASKS_DIR         = r"C:\Users\bob1k\Desktop\MASTER\Thesis\CNN\.venv\old_masks"         # previous run's masks
COMPARE_OUT_DIR       = r"C:\Users\bob1k\Desktop\MASTER\Thesis\CNN\.venv\comparissons"

IMG_EXTS = (".png", ".jpg", ".jpeg", ".bmp", ".tif", ".tiff")

# Sobel + dark gating knobs
STRONG_PCT = 45    # 90..95 keeps only the strongest contrast edges
DARK_THR   = 100    # 60..110 depending on image brightness

# Post-process knobs
DT_SIGMA   = 3     # distance-transform smoothing sigma
MIN_AREA   = 800   # remove white islands smaller than this area (px)
# -------------------------------------------------------------------

# ---------- Option A helper (distance-transform smoothing) ----------
def smooth_mask_distance_transform(mask, sigma=1.5, iters=1):
    m = (mask > 0).astype(np.uint8)
    for _ in range(iters):
        dist_in  = cv2.distanceTransform(m, cv2.DIST_L2, 5)
        dist_out = cv2.distanceTransform((1 - m).astype(np.uint8), cv2.DIST_L2, 5)
        sdf = dist_in - dist_out
        sdf_blur = cv2.GaussianBlur(sdf, (0, 0), sigmaX=sigma, sigmaY=sigma)
        m = (sdf_blur >= 0).astype(np.uint8)
    return (m * 255).astype(np.uint8)

# ---------- Remove small white islands by area -----------------------
def remove_small_components(mask, min_area=150):
    m01 = (mask > 0).astype(np.uint8)
    num, labels, stats, _ = cv2.connectedComponentsWithStats(m01, connectivity=8)
    keep = np.zeros_like(m01, dtype=np.uint8)
    for lbl in range(1, num):  # skip background=0
        if stats[lbl, cv2.CC_STAT_AREA] >= min_area:
            keep[labels == lbl] = 1
    return (keep * 255).astype(np.uint8)

# ---------- Overlay helper -------------------------------------------
def overlay_mask_on_image(image_bgr, mask, alpha=0.4, color_bgr=(0, 0, 255)):
    h, w = image_bgr.shape[:2]
    if mask is None:
        return image_bgr.copy()
    if mask.shape[:2] != (h, w):
        mask = cv2.resize(mask, (w, h), interpolation=cv2.INTER_NEAREST)
    mask01 = (mask > 0).astype(np.uint8)
    color_layer = np.zeros_like(image_bgr, dtype=np.uint8)
    color_layer[mask01 == 1] = color_bgr
    blended = cv2.addWeighted(image_bgr, 1.0, color_layer, alpha, 0.0)
    return blended

# ---------- Label helper ---------------------------------------------
def add_label(image_bgr, text):
    labeled = image_bgr.copy()
    font = cv2.FONT_HERSHEY_SIMPLEX
    scale = 1.0
    thickness = 2
    color = (255, 255, 255)  # white text
    shadow_color = (0, 0, 0)
    (tw, th), _ = cv2.getTextSize(text, font, scale, thickness)
    x = (labeled.shape[1] - tw) // 2
    y = th + 10
    cv2.putText(labeled, text, (x+2, y+2), font, scale, shadow_color, thickness+2, cv2.LINE_AA)
    cv2.putText(labeled, text, (x, y),     font, scale, color,         thickness,   cv2.LINE_AA)
    return labeled

# ---------- Rotate masks: generated_masks -> old_masks ----------------
def rotate_previous_masks(gen_dir, old_dir):
    os.makedirs(gen_dir, exist_ok=True)
    os.makedirs(old_dir, exist_ok=True)
    moved = 0
    for fname in os.listdir(gen_dir):
        if fname.lower().endswith(IMG_EXTS):
            src = os.path.join(gen_dir, fname)
            dst = os.path.join(old_dir, fname)
            # If an old file exists, overwrite it with the previous new one
            try:
                if os.path.exists(dst):
                    os.remove(dst)
                move(src, dst)
                moved += 1
            except Exception:
                pass
    print(f"↻ Rotated {moved} previous masks from generated_masks → old_masks")

# ============================ MAIN ===================================
if __name__ == "__main__":
    os.makedirs(GEN_MASKS_DIR, exist_ok=True)
    os.makedirs(OLD_MASKS_DIR, exist_ok=True)
    os.makedirs(COMPARE_OUT_DIR, exist_ok=True)

    # 1) Rotate previous run's new masks into old_masks (for comparison baseline)
    rotate_previous_masks(GEN_MASKS_DIR, OLD_MASKS_DIR)

    # 2) Process all input images to produce NEW masks + comparisons vs *old_masks*
    for filename in os.listdir(INPUT_DIR):
        if not filename.lower().endswith(IMG_EXTS):
            continue

        img_path = os.path.join(INPUT_DIR, filename)
        image = cv2.imread(img_path)
        if image is None:
            continue

        # -------------------- PREPROCESS ---------------------
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        blurred = cv2.GaussianBlur(gray, (3, 3), 0)

        clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(8, 8))
        contrast = clahe.apply(blurred)

        min_val, max_val = np.min(contrast), np.max(contrast)
        scale = 255.0 / (max_val - min_val + 1e-6)
        shift = -255.0 * min_val / (max_val - min_val + 1e-6)
        stretched = cv2.convertScaleAbs(contrast, alpha=scale, beta=shift)

        # ---------------- SOBEL: strongest DARK edges ----------------
        gx = cv2.Sobel(stretched, cv2.CV_32F, 1, 0, ksize=3)
        gy = cv2.Sobel(stretched, cv2.CV_32F, 0, 1, ksize=3)
        grad = cv2.magnitude(gx, gy)
        grad_norm = cv2.normalize(grad, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

        strong_thr = np.percentile(grad_norm, STRONG_PCT)
        _, strong_edges = cv2.threshold(grad_norm, strong_thr, 255, cv2.THRESH_BINARY)

        dark_mask = (stretched < DARK_THR).astype(np.uint8) * 255
        dark_strong_edges = cv2.bitwise_and(strong_edges, dark_mask)
        dark_strong_edges = cv2.morphologyEx(dark_strong_edges, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8))

        binary = dark_strong_edges

        # -------------- CONNECT + SMOOTH + CLEAN --------------
        kernel_h = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 3))
        kernel_v = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 15))
        closed_h = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel_h)
        closed_v = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel_v)
        closed = cv2.bitwise_or(closed_h, closed_v)

        filled = cv2.morphologyEx(closed, cv2.MORPH_CLOSE, np.ones((2, 2), np.uint8))
        smoothed = smooth_mask_distance_transform(filled, sigma=DT_SIGMA, iters=1)
        cleaned = remove_small_components(smoothed, min_area=MIN_AREA)
        cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_OPEN, np.ones((2, 2), np.uint8))

        # ------------------ SAVE NEW MASK ---------------------
        new_mask_path = os.path.join(GEN_MASKS_DIR, filename)
        cv2.imwrite(new_mask_path, cleaned)

        # ---------------- BUILD COMPARISON -------------------
        # Old mask from rotated folder (may not exist on the first run)
        old_mask_path = os.path.join(OLD_MASKS_DIR, filename)
        old_mask = cv2.imread(old_mask_path, cv2.IMREAD_GRAYSCALE) if os.path.exists(old_mask_path) else None

        overlay_new = overlay_mask_on_image(image, cleaned,   alpha=0.4, color_bgr=(0, 0, 255))
        overlay_old = overlay_mask_on_image(image, old_mask,  alpha=0.4, color_bgr=(0, 0, 255)) if old_mask is not None else image.copy()

        panel_orig = add_label(image,      "Original")
        panel_old  = add_label(overlay_old,"Old Overlay")
        panel_new  = add_label(overlay_new,"New Overlay")

        comparison = np.concatenate([panel_orig, panel_old, panel_new], axis=1)
        comp_path = os.path.join(COMPARE_OUT_DIR, os.path.splitext(filename)[0] + "_compare.png")
        cv2.imwrite(comp_path, comparison)

    print("✅ Rotation complete (generated_masks → old_masks).")
    print("✅ New masks saved to:", GEN_MASKS_DIR)
    print("✅ Comparisons saved to:", COMPARE_OUT_DIR)
